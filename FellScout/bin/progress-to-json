#! /usr/bin/perl
use strict;
use warnings;
use Data::Dumper;
use Text::CSV qw/csv/;
use Getopt::Long;
use Time::Local;
use JSON;

use lib '../local/lib/perl5';

my $in_file = './progress.csv';
my $return_teams = undef;
my $return_entrants = undef;
my $team = undef;
my $help = undef;
my $now = time();

GetOptions (
  "file|f=s" => \$in_file,
  "teams"  => \$return_teams,
  "entrants" => \$return_entrants,
  "help" => \$help,
  "now" => \$now,
  "debug" => \$ENV{DEBUG},
) or abort("Failed to parse command-line options. Try with --help?");

sub usage{
print <<EOF;

$0 ; tool for parsing Felltrack CSV output into JSON

Options:

  --file [file]  Path to the CSV file. Defaults to ./progress.csv
  -f [file]

  --debug        Print debug messages to STDOUT

  --entrants     Return a hash of _all_ entrants; default is just a
                 hash of currently-competing teams

  --help         Show this help

  --now [string] Set 'now' to the given epoch time

EOF

}

# All the times in the CSV file are simply HH:MM and we will want to convert these to a full
# date so we can do normal maths with them.
# To do that, we'll remember that the event starts at 6am, now_hour will be used later in this
# maths

my @timebits = (localtime($now))[3,4,5];
my $now_hour = (localtime($now))[2];

my $entrants = {};
my $teams = {};

my $file_mtime = undef;

my $data = Text::CSV::csv(in => $in_file, headers => "auto", escape_char => "\\", binary => 1, auto_diag => 1, allow_loose_quotes => 1);

# Starts at 2 since the heading is row 1. Used entirely in debug output.
my $rownum = 2;

foreach my $row (@{$data}){
  my $entrant;

  $entrant->{code}         = $row->{Number};
  $entrant->{name}         = $row->{Name};
  $entrant->{team_name}    = $row->{Team};
  $entrant->{route}        = $row->{Route};
  $entrant->{total_time}   = $row->{"Total time"};
  $entrant->{completed}    = $row->{Complete};
  $entrant->{waiting_time} = $row->{'Waiting time'};
  $entrant->{unit}         = $row->{'Extra field 2'};
  $entrant->{district}     = $row->{'Extra field 1'};

  $entrant->{completed_hhmm} = $row->{'The finish'};
  $entrant->{completed_hhmm} =~ s/://;

  my @checkpoints;
  foreach my $key (sort(keys(%{$row}))){
    if ($key =~ m/^CP(\d+)$/){
      $checkpoints[$1] = $row->{$key}
    }
  }

  debug("[row $rownum] Entrant $entrant->{code}; name: $entrant->{name}");


  # Here we iterate over the entrant's checkpoints. Each will either be empty,
  # in which case it's not (yet) been visited (it might also be a skipped point
  # that is used only by routes shorter than this entrant's), contain the word
  # 'missed' which means that it _is_ en-route but the entrant has already
  # checked-in to a checkpoint after it, or contain a time in the format HH:MM,
  # optionally with a modifier letter:
  #  R = Retired (and then the time is the time they retired)
  #  M = Manual Entry (the time is the manually-entered time)
  my $last_cp_hhmm_numeric = 0;
  for (my $cp_number = 1; $cp_number <= @checkpoints; $cp_number++){
    my $hhmm = $checkpoints[$cp_number];
    next if !$hhmm or $hhmm eq '';
    if($hhmm =~ m/R$/){
      debug("[row $rownum] $entrant->{code} retired at CP $cp_number ($hhmm)");
      $entrant->{retired} = $cp_number;
      $hhmm =~ s/R$//;
    }
    if($hhmm =~ m/^M/){
      $entrant->{checkpoints}->{$cp_number}->{manual} = 'true';
      $hhmm =~ s/^M//;
    }
    if($hhmm eq 'missed'){
      $entrant->{checkpoints}->{$cp_number}->{missed} = 'true';
      next;
    }

    # Here we deal with the problem that all times are simple HH:MM with no date
    # information.
    # The first cp from any entrant will be on the first day of the event, so we
    # assume that when the hour value drops this must be because midnight has
    # happened. At the first checkpoint where the time goes 'backwards' we set the
    # _added_days key on the entrant to '1', which persists for the rest of the
    # checkpoints
    my $hhmm_numeric = $hhmm;
    $hhmm_numeric =~ s/://;
    unless( !$hhmm_numeric or $hhmm_numeric == 0){
      my $added_days = $entrant->{checkpoints}->{$cp_number -1 }->{_added_days} || 0;
      if($hhmm_numeric < $last_cp_hhmm_numeric){
        debug("Went from $last_cp_hhmm_numeric to $hhmm_numeric; assuming midnight happened");
        $added_days += 1;
      }
      $last_cp_hhmm_numeric = $hhmm_numeric;
      my $time = mmhh_to_epoch( $hhmm, $added_days );
      debug("[row $rownum] Entrant $entrant->{code} CP $cp_number: $time ( $hhmm ) ".localtime($time));
      $entrant->{checkpoints}->{$cp_number}->{arrived_time} = $time;
      $entrant->{checkpoints}->{$cp_number}->{arrived_localtime} = localtime($time);
      $entrant->{checkpoints}->{$cp_number}->{arrived_hhmm} = $hhmm;
      $entrant->{checkpoints}->{$cp_number}->{arrived_hhmm_numeric} = $hhmm_numeric;
      $entrant->{checkpoints}->{$cp_number}->{_added_days} = $added_days;
    }

    foreach my $cp ( keys %{$entrant->{checkpoints}}){
      if ($entrant->{checkpoints}->{$cp}->{arrived_time}){
        $entrant->{last_checkpoint} = $cp;
      }
    }
  }

  # The entrants hash contains every person who entered, so _everyone_ gets added to this hash...
  $entrants->{ $entrant->{code} } = $entrant;

  # But the Teams one is only those teams still in on it, so we don't bother with entrants who have
  # retired or finished
  if( $entrant->{retired}){
    debug("Entrant $entrant->{code} has retired");
  }elsif( $entrant->{completed_hhmm} > 0 ){
    debug("Entrant $entrant->{code} finished at $entrant->{completed_hhmm} ");
  }else{
    unless( $entrant->{code} =~ m/^(\d+)([A-Z]+)$/ ){
      error("Invalid entrant code '$entrant->{code}'");
      next;
    }
    my $team_number = $1;
    $entrant->{team_number} = $team_number;
    $entrant->{letter} = $2;
    debug("Entrant $entrant->{code} ($entrant->{name}) is still going");
    # Pick an entrant and use them to represent the team
    unless($teams->{ $entrant->{team_number} }->{name}){
      %{$teams->{ $team_number}} = %{$entrant};
      delete($teams->{$team_number}->{name});
      delete($teams->{$team_number}->{complete});
      delete($teams->{$team_number}->{waiting_time});
      delete($teams->{$team_number}->{number});

      $teams->{$team_number}->{name} = $entrant->{team_name};
      $teams->{$team_number}->{number} = $entrant->{team_number};
      $teams->{$team_number}->{route} = $entrant->{route};
      $teams->{$team_number}->{representantive_member} = $entrant->{letter};
      $teams->{$team_number}->{district} = $entrant->{district};
      $teams->{$team_number}->{unit} = $entrant->{unit};
    }
    $teams->{$team_number}->{entrants}->{$entrant->{code}} = $entrant->{name};
    debug("Adding $entrant->{letter} ($entrant->{name}) to team $team_number $teams->{$team_number}->{team_name}");
  }
  $rownum++;
}

if (!$entrants || !$teams){
  abort("Failed to create entrants or teams hash!");
}

my $return = {};
$return->{file} = $in_file;
$return->{file_mtime} = $file_mtime;
$return->{time_generated} = $now;
if($return_entrants){
  $return->{entrants} = $entrants;
}
if($return_teams){
  $return->{teams} = $teams;
}

binmode(STDOUT, ":utf8");
print to_json($return);
exit 0;


sub mmhh_to_epoch{
  my $time = shift;
  my $added_days = shift || 0;
  abort("[$.] Invalid time: '$time'") unless $time =~ m/^(\d\d?):(\d\d?)/;
  my @_timebits = @timebits;
  $_timebits[0] += $added_days;
  my ($h,$m) = ($1,$2);
  my $timestamp = timelocal(0, $m, $h, @_timebits);
  return $timestamp;
}

sub abort{
  my $message = shift;
  error($message);
  error("Aborting.");
  exit 1;
}

sub error{
  my $message = shift;
  chomp($message);
  print STDERR "ERROR: $message\n";
}

sub debug{
  return unless $ENV{DEBUG};
  my $message = shift;
  chomp($message);
  print STDERR "DEBUG: $message\n";
}
